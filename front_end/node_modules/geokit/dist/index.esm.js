/**
 * Get Base 32 symbol from decimal chunk (5 bit binary value).
 * @param value Decimal value of chunk (5 bit binary value).
 * @returns Base 32 value.
 */
function base32(value) {
    return '0123456789bcdefghjkmnpqrstuvwxyz'.charAt(value);
}
/**
 * Get decimal chunk (5 bit binary value) from Base 32 character.
 * @param value Base 32 character.
 * @returns Decimal value of chunk (5 bit binary value).
 */
function decimalChunk(value) {
    return '0123456789bcdefghjkmnpqrstuvwxyz'.indexOf(value.toLowerCase());
}
/**
  * Determine if coordinate is greater than midle of range in a bit representation.
  * @param point Coordinates.
  * @param range Range of coordinates to check.
  * @returns Number representation if point is greater than the middle of the range.
  */
function getBit(point, range) {
    var middle = (range[0] + range[1]) / 2;
    return (middle > point) ? 0 : 1;
}
/**
 * Get radians from degrees.
 * @param degrees Degrees.
 * @returns Radians.
 */
function toRad(degrees) {
    return (degrees * Math.PI / 180);
}
/**
 * Validates user inputted coordinates.
 * @param coordinates User inputted coordinates.
 * @returns Error.
 */
function validateCoordinates(coordinates) {
    var error = [];
    if (coordinates.lat > 90) {
        error.push('Your latitude is greater than 90째');
    }
    if (coordinates.lat < -90) {
        error.push('Your latitude is less than -90째');
    }
    if (coordinates.lng > 180) {
        error.push('Your longitude is greater than 180째');
    }
    if (coordinates.lng < -180) {
        error.push('Your longitude is less than -180째');
    }
    if (error.length !== 0) {
        return new Error(error.join(' '));
    }
}

/**
 * A class for the Geokit.
 */
var Geokit = /** @class */ (function () {
    function Geokit() {
    }
    /**
     * Get the distance between two coordinates.
     * @param start Starting coordinates.
     * @param end Ending coordinates.
     * @param unit Unit of distance returned, defaults to Km.
     * @returns The distance between two coordinates.
     */
    Geokit.distance = function (start, end, unit) {
        if (unit === void 0) { unit = 'km'; }
        var startValid = validateCoordinates(start);
        if (startValid instanceof Error) {
            throw new Error('Start coordinates: ' + startValid.message);
        }
        var endValid = validateCoordinates(end);
        if (endValid instanceof Error) {
            throw new Error('End coordinates: ' + endValid.message);
        }
        var radius = (unit.toLowerCase() === 'miles') ? 3963 : 6371;
        var dLat = toRad(end.lat - start.lat);
        var dLon = toRad(end.lng - start.lng);
        var lat1 = toRad(start.lat);
        var lat2 = toRad(end.lat);
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return (radius * c);
    };
    /**
     * Get the geohash of a point.
     * @param coordinates Coordinates to hash.
     * @param precision Precision of hash desired, defaults to 10.
     * @returns Geohash of point.
     */
    Geokit.hash = function (coordinates, precision) {
        if (precision === void 0) { precision = 10; }
        var valid = validateCoordinates(coordinates);
        if (valid instanceof Error) {
            throw valid;
        }
        var hash = '';
        var latRng = [-90, 90];
        var lngRng = [-180, 180];
        while (hash.length < precision) {
            var temp = 0;
            for (var i = 0; i < 5; i++) {
                var even = (((hash.length * 5) + i) % 2) == 0;
                var coord = (even) ? coordinates.lng : coordinates.lat;
                var range = (even) ? lngRng : latRng;
                var middle = (range[0] + range[1]) / 2;
                temp = (temp << 1) + getBit(coord, range);
                (coord > middle) ? range[0] = middle : range[1] = middle;
            }
            hash += base32(temp);
        }
        return hash;
    };
    /**
     * Decodes a Geohash into a LatLngLiteral.
     * @param hash Geohash string.
     * @returns Coordinates to hash.
     */
    Geokit.decodeHash = function (hash) {
        var even = true;
        var latRng = [-90, 90];
        var lngRng = [-180, 180];
        var hashChars = hash.split('');
        while (hashChars.length) {
            var chunk = decimalChunk(hashChars.shift());
            for (var i = 0; i < 5; i++) {
                var mask = [16, 8, 4, 2, 1][i];
                var range = (even) ? lngRng : latRng;
                var middle = (range[0] + range[1]) / 2;
                range[((chunk & mask) ? 0 : 1)] = middle;
                even = !even;
            }
        }
        return { lat: ((latRng[0] + latRng[1]) / 2), lng: ((lngRng[0] + lngRng[1]) / 2) };
    };
    return Geokit;
}());

export { Geokit };
